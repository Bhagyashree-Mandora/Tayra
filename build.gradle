apply plugin: 'groovy'
apply plugin: 'eclipse'
apply plugin: 'idea'

apply plugin: 'checkstyle' //for java code conventions
apply plugin: 'jdepend'  //for dependency analysis
apply plugin: 'findbugs' //for static code analysis
apply plugin: 'pmd'

defaultTasks 'clean', 'build'

sourceCompatibility = '1.6'
targetCompatibility = '1.6'

project.ext {

  //App Config
  appConfigUrl = new URL("file:///${projectDir}/AppConfig.groovy")
  appConfig = new ConfigSlurper('configuration').parse(appConfigUrl).configuration
  manifest = project.ext.appConfig.product.distribution.jar.manifest.details

  //libs
  mongoDriver = 'org.mongodb:mongo-java-driver:2.10.1'
  groovy = 'org.codehaus.groovy:groovy-all:2.0.5'
  commonsCli = 'commons-cli:commons-cli:1.1'
  functionaljava = 'org.functionaljava:functionaljava:3.1'
  log4j = 'log4j:log4j:1.2.17'

  //test-libs
  junit = 'junit:junit:4.8.1'
  hamcrest = 'org.hamcrest:hamcrest-all:1.3'
  mockito = 'org.mockito:mockito-all:1.9.0'
  cglib = 'cglib:cglib-nodep:2.2'
  spock = 'org.spockframework:spock-core:0.7-groovy-2.0'
  unmanagedTestLibDir = "$projectDir/test-lib"

  //code coverage lib
  coberturaLib = 'net.sourceforge.cobertura:cobertura:1.9.4.1'
  instrumentedClassesDir = "$project.buildDir/classes/instrumented"
  coverageReportsDir = "$reporting.baseDir/cobertura"
  coverageDataFile = 'cobertura.ser'
  lineCoverageBaseline = 85
  branchCoverageBaseline = 70

  //Distribution settings
  distsTemplateDir = 'distribution-template'
  distsBinDir = "$distsDir/bin"
  
  //Acceptance Tests
  acceptanceTestDir = 'acceptance-tests'
  acceptanceTestStoriesDir = "$projectDir/$acceptanceTestDir/stories/played"
  acceptanceTestReportsDir = "$reporting.baseDir/$acceptanceTestDir"
  smokeTestDir = "$acceptanceTestStoriesDir/cud"

  explodedDir = "$project.buildDir/exploded"
  executionEnv = "${System.getProperty('env', 'dev')}"

}

project.archivesBaseName = project.ext.appConfig.product.distribution.name

repositories {
  mavenCentral()
  mavenRepo url: 'http://bits.netbeans.org/maven2/'
  mavenRepo url: 'http://functionaljava.googlecode.com/svn/maven/'
  mavenRepo url: 'http://code.google.com/p/google-maven-repository'
}

configurations {
	cobertura
	compile
    tests
}

dependencies {
  groovy(groovy)
  compile(project.ext.mongoDriver, project.ext.groovy, project.ext.commonsCli, project.ext.functionaljava, project.ext.log4j)
  testCompile(project.ext.hamcrest, project.ext.junit, project.ext.mockito, project.ext.spock, project.ext.cglib)
  testCompile fileTree (dir: "$unmanagedTestLibDir", includes: ['*.jar'])
  cobertura(project.ext.coberturaLib)
  testRuntime(project.ext.coberturaLib)
}

jar {
	manifest {
		attributes.putAll(project.ext.manifest)
	}

	doLast {
        copy {
            from (configurations.compile.asPath.split(File.pathSeparator))
            into "$libsDir"
        }
    }
}

clean << {
	ant.delete(file:"$coverageDataFile")
}

test {
    println "Utilizing properties from $project.ext.executionEnv Environment"
    systemProperties['env'] = project.ext.executionEnv
	def originalClasspath = getClasspath()
	doFirst {
		ant.taskdef(resource:'tasks.properties', classpath:configurations.cobertura.asPath)
		//Note the classpath order: instrumented classes are before the original
		//uninstrumented classes.  This is important
		setClasspath(files("$instrumentedClassesDir") + originalClasspath)

		ant.'cobertura-instrument'(todir:project.ext.instrumentedClassesDir) {
			ignore(regex:"org.apache.*, com.mongodb.*")
			fileset(dir:"${project.buildDir}/classes/main", includes:'**/*.class', excludes:'**/*Specs.class')
		}
	}

	doLast {
		ant.'cobertura-report'(destDir: project.ext.coverageReportsDir, format:'xml') {
			sourceSets.main*.java.srcDirs*.each { fileset(dir:it) }
			sourceSets.main*.groovy.srcDirs*.each { fileset(dir:it) }
		}
		ant.'cobertura-report'(destDir: project.ext.coverageReportsDir, format:'html') {
			sourceSets.main*.java.srcDirs*.each { fileset(dir:it) }
			sourceSets.main*.groovy.srcDirs*.each { fileset(dir:it) }
		}
		ant.'cobertura-check'(totalbranchrate:project.ext.branchCoverageBaseline, totallinerate:project.ext.lineCoverageBaseline)
		setClasspath(originalClasspath)
	}
}

// For individual use only, assumes you have binaries existing already.
task ('smoke-test', dependsOn: ['testJar', 'unzip']) << {
    println "Running FIT Smoke Test..."
    runAcceptanceTests(project.ext.smokeTestDir, project.ext.acceptanceTestReportsDir)
}

// For individual use only, assumes you have binaries existing already.
task ('acceptance-test', dependsOn: ['testJar', 'unzip']) << {
    println "Running FIT Acceptance Tests..."
    runAcceptanceTests(project.ext.acceptanceTestStoriesDir, project.ext.acceptanceTestReportsDir)
}

def runAcceptanceTests(String srcFolder, String reportsFolder) {
    def runtimeClasspath = fileTree(dir: "${project.ext.explodedDir}/libs", include: '*.jar')
    runtimeClasspath = runtimeClasspath + fileTree(dir: project.ext.unmanagedTestLibDir, include: '*.jar')
    runtimeClasspath = runtimeClasspath + fileTree(dir: project.distsDir, include: '*.jar')

    def accTestReportsDir = new File("$project.ext.acceptanceTestReportsDir")
	if(!accTestReportsDir.exists()) {
		accTestReportsDir.mkdirs()
	}
	javaexec {
        systemProperties['env'] = project.ext.executionEnv
	    main = 'fitlibrary.runner.FolderRunner'
	    classpath = runtimeClasspath
	    args = ["$srcFolder", "$reportsFolder"]
	}
}

task unzip(type: Copy) {
    def zipFile = file("${project.distsDir}/${project.archivesBaseName}.zip")
    def outputDir = file(project.ext.explodedDir)

    from zipTree(zipFile)
    into outputDir
}

// For individual use only, assumes you have binaries existing already.
task testJar(type: Jar) {
  baseName = "${project.archivesBaseName}-test"
  destinationDir = project.distsDir
  from sourceSets.test.output
}

task distribute(type:Zip, dependsOn: 'assemble') {
	doFirst {
		ant.mkdir(dir:"$distsBinDir")
		prepareExecutables()
	}
	from "$project.ext.distsBinDir"
	from ("$project.ext.distsTemplateDir") { include ('**/*.txt', '**/*.document', '**/*.rtf') }
	from("$libsDir") { into('libs') }
}

findbugs {
	toolVersion = "2.0.1"
	reportsDir = file("$reporting.baseDir/findbugs")
	effort = "max"
	reportLevel = "high"
}

tasks.withType(FindBugs) {
	excludeFilter = file("${projectDir}/config/findbugs/excludeFilter.xml")
}

checkstyleTest {
	exclude('**/*/*Specs.java')
}

//findbugsTest.enabled = false

def prepareExecutables() {
	def allLibFiles = new File("$libsDir").list().collect { "libs/$it" }
	new File("$distsTemplateDir").list().each { filename ->
		if(filename.startsWith('backup') || filename.startsWith('restore')) {
			def contents = new File("$distsTemplateDir/$filename").text
			new FileWriter("$distsBinDir/$filename").withWriter { writer ->
				if(filename.endsWith('.sh')) {
					writer.append contents.replace('%%JAVA_CLASS_PATH%%', allLibFiles.collect({"\$TAYRA_HOME/$it"}).join(":"))
				}
				if(filename.endsWith('.bat')) {
					writer.append contents.replace('%%JAVA_CLASS_PATH%%', allLibFiles.collect({"%TAYRA_HOME%/$it"}).join(";"))
				}
			}
		}
	}
}

build.dependsOn = ['check', 'distribute', 'smoke-test']
